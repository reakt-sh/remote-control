# Code generated by bitproto. DO NOT EDIT.


import json
from dataclasses import dataclass, field
from typing import ClassVar, Dict, List, Union
from enum import IntEnum, unique

from bitprotolib import bp


@unique
class Mode(IntEnum): # 3bit
    DRIVE_MODE_NEUTRAL = 0
    DRIVE_MODE_FORWARD = 1
    DRIVE_MODE_REVERSE = 2
    DRIVE_MODE_PARKING = 3
    DRIVE_MODE_EMERGENCY_STOP = 4
# In a heartbeat message, the driver will ignore remaining payload (just a keep-alive message)
    HEARTBEAT = 5
    UNUSED_B = 6
    UNUSED_C = 7


# Aliases for backwards compatibility
DRIVE_MODE_NEUTRAL: Mode = Mode.DRIVE_MODE_NEUTRAL
DRIVE_MODE_FORWARD: Mode = Mode.DRIVE_MODE_FORWARD
DRIVE_MODE_REVERSE: Mode = Mode.DRIVE_MODE_REVERSE
DRIVE_MODE_PARKING: Mode = Mode.DRIVE_MODE_PARKING
DRIVE_MODE_EMERGENCY_STOP: Mode = Mode.DRIVE_MODE_EMERGENCY_STOP
# In a heartbeat message, the driver will ignore remaining payload (just a keep-alive message)
HEARTBEAT: Mode = Mode.HEARTBEAT
UNUSED_B: Mode = Mode.UNUSED_B
UNUSED_C: Mode = Mode.UNUSED_C


_MODE_VALUE_TO_NAME_MAP: Dict[Mode, str] = {
    Mode.DRIVE_MODE_NEUTRAL: "DRIVE_MODE_NEUTRAL",
    Mode.DRIVE_MODE_FORWARD: "DRIVE_MODE_FORWARD",
    Mode.DRIVE_MODE_REVERSE: "DRIVE_MODE_REVERSE",
    Mode.DRIVE_MODE_PARKING: "DRIVE_MODE_PARKING",
    Mode.DRIVE_MODE_EMERGENCY_STOP: "DRIVE_MODE_EMERGENCY_STOP",
    Mode.HEARTBEAT: "HEARTBEAT",
    Mode.UNUSED_B: "UNUSED_B",
    Mode.UNUSED_C: "UNUSED_C",
}

def bp_processor_Mode() -> bp.Processor:
    return bp.EnumProcessor(bp.Uint(3))


@unique
class ErrorState(IntEnum): # 2bit
    NO_ERROR = 0
    ERROR = 1
    FATAL_ERROR = 3


# Aliases for backwards compatibility
NO_ERROR: ErrorState = ErrorState.NO_ERROR
ERROR: ErrorState = ErrorState.ERROR
FATAL_ERROR: ErrorState = ErrorState.FATAL_ERROR


_ERRORSTATE_VALUE_TO_NAME_MAP: Dict[ErrorState, str] = {
    ErrorState.NO_ERROR: "NO_ERROR",
    ErrorState.ERROR: "ERROR",
    ErrorState.FATAL_ERROR: "FATAL_ERROR",
}

def bp_processor_ErrorState() -> bp.Processor:
    return bp.EnumProcessor(bp.Uint(2))


@dataclass
class StatusMessage(bp.MessageBase):
    # Number of bytes to serialize class StatusMessage
    BYTES_LENGTH: ClassVar[int] = 10

    # // System state
    # If an error occurred an error appendix message will follow directly after this message!
    error: Union[int, ErrorState] = ErrorState.NO_ERROR
    # This field is a proxy to hold integer value of enum field 'error'
    _enum_field_proxy__error: int = field(init=False, repr=False) # 2bit
    remote_control: bool = False # 1bit
    # Time since system start in ms. Receiving end must handle overflows
    time: int = 0 # 32bit
    # // Motor control state
    mode: Union[int, Mode] = Mode.DRIVE_MODE_NEUTRAL
    # This field is a proxy to hold integer value of enum field 'mode'
    _enum_field_proxy__mode: int = field(init=False, repr=False) # 3bit
    motor_rpm: int = 0 # 13bit
    target_rpm: int = 0 # 13bit
    # // Internal state
    control_rpm: int = 0 # 13bit

    def __post_init__(self):
        # initialize handling of enum field 'error' as `enum.IntEnum`
        if not isinstance(getattr(StatusMessage, "error", False), property):
            self._enum_field_proxy__error = self.error
            StatusMessage.error = property(StatusMessage._get_error, StatusMessage._set_error)  # type: ignore
        # initialize handling of enum field 'mode' as `enum.IntEnum`
        if not isinstance(getattr(StatusMessage, "mode", False), property):
            self._enum_field_proxy__mode = self.mode
            StatusMessage.mode = property(StatusMessage._get_mode, StatusMessage._set_mode)  # type: ignore

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def _get_error(self) -> ErrorState:
        """property getter for enum proxy field"""
        return ErrorState(self._enum_field_proxy__error)

    def _set_error(self, val):
        """property setter for enum proxy field"""
        self._enum_field_proxy__error = val
    def _get_mode(self) -> Mode:
        """property getter for enum proxy field"""
        return Mode(self._enum_field_proxy__mode)

    def _set_mode(self, val):
        """property setter for enum proxy field"""
        self._enum_field_proxy__mode = val

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp_processor_ErrorState()),
            bp.MessageFieldProcessor(2, bp.Bool()),
            bp.MessageFieldProcessor(3, bp.Uint(32)),
            bp.MessageFieldProcessor(10, bp_processor_Mode()),
            bp.MessageFieldProcessor(11, bp.Uint(13)),
            bp.MessageFieldProcessor(12, bp.Uint(13)),
            bp.MessageFieldProcessor(21, bp.Uint(13)),
        ]
        return bp.MessageProcessor(False, 77, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.error |= (ErrorState(b) << lshift)
        if di.field_number == 2:
            self.remote_control = bool(b)
        if di.field_number == 3:
            self.time |= (int(b) << lshift)
        if di.field_number == 10:
            self.mode |= (Mode(b) << lshift)
        if di.field_number == 11:
            self.motor_rpm |= (int(b) << lshift)
        if di.field_number == 12:
            self.target_rpm |= (int(b) << lshift)
        if di.field_number == 21:
            self.control_rpm |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.error >> rshift) & 255
        if di.field_number == 2:
            return (int(self.remote_control) >> rshift) & 255
        if di.field_number == 3:
            return (self.time >> rshift) & 255
        if di.field_number == 10:
            return (self.mode >> rshift) & 255
        if di.field_number == 11:
            return (self.motor_rpm >> rshift) & 255
        if di.field_number == 12:
            return (self.target_rpm >> rshift) & 255
        if di.field_number == 21:
            return (self.control_rpm >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class ErrorAppendixMessage(bp.MessageBase):
    # Number of bytes to serialize class ErrorAppendixMessage
    BYTES_LENGTH: ClassVar[int] = 8

    errors: int = 0 # 64bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(64)),
        ]
        return bp.MessageProcessor(False, 64, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.errors |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.errors >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class ControlMessage(bp.MessageBase):
    # Number of bytes to serialize class ControlMessage
    BYTES_LENGTH: ClassVar[int] = 2

    mode: Union[int, Mode] = Mode.DRIVE_MODE_NEUTRAL
    # This field is a proxy to hold integer value of enum field 'mode'
    _enum_field_proxy__mode: int = field(init=False, repr=False) # 3bit
    target_rpm: int = 0 # 13bit

    def __post_init__(self):
        # initialize handling of enum field 'mode' as `enum.IntEnum`
        if not isinstance(getattr(ControlMessage, "mode", False), property):
            self._enum_field_proxy__mode = self.mode
            ControlMessage.mode = property(ControlMessage._get_mode, ControlMessage._set_mode)  # type: ignore

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def _get_mode(self) -> Mode:
        """property getter for enum proxy field"""
        return Mode(self._enum_field_proxy__mode)

    def _set_mode(self, val):
        """property setter for enum proxy field"""
        self._enum_field_proxy__mode = val

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp_processor_Mode()),
            bp.MessageFieldProcessor(2, bp.Uint(13)),
        ]
        return bp.MessageProcessor(False, 16, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.mode |= (Mode(b) << lshift)
        if di.field_number == 2:
            self.target_rpm |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.mode >> rshift) & 255
        if di.field_number == 2:
            return (self.target_rpm >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return